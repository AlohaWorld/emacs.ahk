/**
 * This script emulate emacs keybindings in Windows
 *
 * <p>This work is motivated by usi3's emacs.ahk scrpit.
 * @see <a href="https://github.com/usi3/emacs.ahk">usi3's emacs.ahk</a>
 * 
 * @author <a href="mailto:aloha.world@outlook.com">Yidong Cui</a>
 * @version 1.0.1
 * @since 2020/08/10
*/

/**
 * Copyright 2020 Yidong Cui
 *
 * <p>This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * <p>This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * <p>You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

;; Directives
; Check 
#Requires AutoHotkey v2.0-a
; MsgBox "This script will run only on v2.0, including alpha releases."

; Forces the unconditional installation of the keyboard hook.
#InstallKeybdHook

; Forces the use of the hook to implement all or some keyboard hotkeys.
; #UseHook On ; ahk v1 use on/off
#UseHook True

; Enables or disables warnings for specific conditions which may indicate an
; error, such as a typo or missing "global" declaration.
#Warn

/**
 * TODO: Use "ListHotkeys" to show all hotkeys that current script use
*/

; The following line is a contribution of NTEmacs wiki http://www49.atwiki.jp/ntemacs/pages/20.html
; Sets the delay that will occur after each keystroke sent by Send or ControlSend
; 0 for the smallest possible delay, -1 for no delay at all, leaving blank to retain the current Delay
SetKeyDelay 0

/**
 * App holds the application information.
 * <p>
 * <li> appName holds the name of the application;
 * <li> appExe holds the executable filename of the application;
 * <li> appClass holds the windows class of the application; 
 * <li> appLevel identifies how this script deals with it: simply igore it or do extra processing
 */
class App {
  appName :="None"
  appClass:="None"
  appExe  :="None"
  appLevel:=1
  
  /**
   * Constructs an App object with parameters
   */
  __New(aName, aClass, aExe, aLevel){
    this.appName := aName
	this.appClass := aClass	
	this.appExe := aExe

    /** appLevel
     * 1: Do NOT need emacs keybingdings at all
     */
	this.appLevel := aLevel
  }
}
class AppFilter {
  appList := [ 
     App.new("Cygwin", "ConsoleWindowClass", "", 1)
	,App.new("CygwinX", "cygwin/x X rl-xterm-XTerm-0", "", 1)
	,App.new("Firefox Browser", "MozillaUIWindowClass", "", 1)
    ,App.new("GVim", "Vim", "", 1) ; GVIM
    ,App.new("Exlipse", "SWT_Window0", "", 1) ; Eclipse
    ,App.new("Emacs for Windows", "Emacs", "", 1) ; NTEmacs
    ,App.new("ConEmu", "VirtualConsoleClass", "", 1) ; ConEmu
    ,App.new("SecureCRT", "VanDyke Software - SecureCRT", "", 1)
    ,App.new("Visual Studio Code", "", "Code.exe", 1)
	,App.new("Visual Studio", "", "devenv.exe", 1)
  ]
  /**
   * Check if current window/application is in the igorenant list.
   * <p>
   * If the windows/application is in the list, return the app's Level.
   * @param No parameters
   * @return number, which means the application's level.
   */
  isTarget(){
    for (myapp in this.appList) {
	  activeString := ""
	  if (myapp.appClass != "") {
	    activeString := "ahk_class " . myapp.appClass
	  } else if (myapp.appExe !=""){
	    activeString := "ahk_exe " . myapp.appExe
	  } else {
	    throw "Check your application information in AppFilter.appList[] : " . myapp.appName
	  }
	  if (WinActive(activeString)) {
	    return myapp.appLevel
	  }
	} ; end for (myapp...)
	return 0
  } ; end isTarget()

  /**
   * print() is used to display target applications in a message box. <br>
   * This function is for debug purpose only. <br>
   * @param No parameters
   * @return No return values
   */
  print() { ; Show all target apps in message box. For debug purpose only.
    for (myapp in this.appList) {
	  str := myapp.appName "'s exe file is: " myapp.appExe ", and its window class is: " myapp.appClass ", te level is: " myapp.appLevel
	  MsgBox(str, "Info", "OK Iconi")
	}
  }
}

myAppFilter := AppFilter.new()
;; For debug purpose only
;myAppFilter.print()

; turns to be 1 when ctrl-x is pressed
is_pre_x := 0
; turns to be 1 when ctrl-space is pressed, which is in selection mode
is_pre_spc := 0

; Applications you want to disable emacs-like keybindings
; (Please comment out applications you don't use)
is_target() {
  global
  return myAppFilter.isTarget()
}

delete_char()
{
  Send("{Del}")
  global is_pre_spc := 0
  return
}
delete_backward_char()
{
  Send "{BS}"
  global is_pre_spc := 0
  return
}
/*
 * kill_line() is intercepted from ntemacs.ahk
 */
kill_line()
{
  global
  is_pre_spc := 1
  move_end_of_line()
  Send "^c{Del}"
  is_pre_spc := 0
}
/** Below function is written by usi3. Now obsoleted

kill_line()
{
  Send {ShiftDown}{END}{SHIFTUP}
  Sleep 50 ;[ms] this value depends on your environment
  Send ^x
  global is_pre_spc = 0
  return
}
*/
open_line(){
  Send "{END}{Enter}{Up}"
  global is_pre_spc := 0
  return
}

quit(){
  global
  Send "{ESC}"
  
  if(is_pre_spc) { ; Cancel the selection mode
    Send("{Right}") ; Here we cannot obtain where the cursor is.
  }
  ;; All previous states are cleared
  is_pre_spc := 0
  is_pre_x := 0
  return
}

newline()
{
  Send "{Enter}"
  global is_pre_spc := 0
  return
}
indent_for_tab_command()
{
  Send "{Tab}"
  global is_pre_spc := 0
  return
}
newline_and_indent(){
  Send "{Enter}{Tab}"
  global is_pre_spc := 0
  return
}

isearch_forward(){
  Send "^f"
  global is_pre_spc := 0
  return
}

isearch_backward()
{
  Send "^f"
  global is_pre_spc := 0
  return
}
kill_region(){
  Send "^x"
  global is_pre_spc := 0
  return
}

kill_ring_save()
{
  Send "^c"
  global is_pre_spc := 0
  return
}
yank(){
  Send "^v"
  global is_pre_spc := 0
  return
}

undo(){
  Send "^z"
  global is_pre_spc := 0
  return
}

find_file(){
  Send "^o"
  global is_pre_x := 0
  return
}

save_buffer(){
  Send("^s")
  global is_pre_x := 0
  return
}

select_all(){ ;Bind to Ctrl-x, h
  Send("^a")
  global is_pre_x := 0
  return
}

kill_buffer(){ ;Bind to Ctrl-x,k  which will kill current tab/window
  Send("^w")
  global is_pre_x := 0
  return
}

kill_emacs(){
  Send("!{F4}")
  global is_pre_x := 0
  return
}

move_beginning_of_line(){
  global
  if is_pre_spc
    Send "+{HOME}"
  Else
    Send "{HOME}"
  return
}

move_end_of_line() {
  global
  if (is_pre_spc) {
    if (WinActive("ahk_class OpusApp")) { ; Microsoft Word
      Send "+{End}+{Left}"
    } else {
      Send "+{End}"
    }
  } else {
    Send "{End}"
  }
  return
}

previous_line(){
  global
  if is_pre_spc
    Send "+{Up}"
  Else
    Send "{Up}"
  return
}

next_line(){
  global
  if is_pre_spc
    Send "+{Down}"
  Else
    Send "{Down}"
  return
}

forward_char(){
  global
  if is_pre_spc
    Send "+{Right}"
  Else
    Send "{Right}"
  return
}

forward_word(){
  global
  if(is_pre_spc)
    Send "^+{Right}"
  else
    Send "^{Right}"
}

backward_char(){
  global
  if(is_pre_spc)
    Send("+{Left}")
  Else
    Send "{Left}"
  return
}

backward_word(){
  global
  if(is_pre_spc)
    Send "^+{Left}"
  else
    Send "^{Left}"
}
scroll_up(){
  global
  if is_pre_spc
    Send "+{PgUp}"
  else
    Send "{PgUp}"
  return
}

scroll_down(){
  global
  if is_pre_spc
    Send "+{PgDn}"
  else
    Send "{PgDn}"
  return
}

/**
 * We use ThisHotkey instead of A_ThisHotkey
 * A_ThisHotkey: The most recently executed hotkey or non-auto-replace 
 *               hotstring (blank if none). This value will change if the 
 *               current thread is interrupted by another hotkey or hotstring
 */
^a::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
    move_beginning_of_line()
  return
}

^b::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
    backward_char()
  return
}

!b::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
  {
    backward_word()
  }
  return  
}

^c::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
  {
    if is_pre_x
      kill_emacs()
  }
  return  
}
^d::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
    delete_char()
  return
}

^e::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
    move_end_of_line()
  return
}

^f::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
  {
    if is_pre_x
      find_file()
    else
      forward_char()
  }
  return  
} 

!f::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
  {
    forward_word()
  }
  return  
}

^g::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
    quit()
  return
}

^h::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
    delete_backward_char()
  return
}

^i::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
    indent_for_tab_command()
  return
}

;; ^j::
;;   if is_target()
;;     Send %A_ThisHotkey%
;;   else
;;     newline_and_indent()
;;   return

^k::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
    kill_line()
  return
}

^m::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
    newline()
  return
}

^n::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
    next_line()
  return
}

;; ^o::
;;   if is_target()
;;     Send %A_ThisHotkey%
;;   else
;;     open_line()
;;   return

^p::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
    previous_line()
  return
}

^r::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
    isearch_backward()
  return
}

^s::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
  {
    if is_pre_x
      save_buffer()
    else
      isearch_forward()
  }
  return
}

^v::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
    scroll_down()
  return
}

!v::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
    scroll_up()
  return
}

^w::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
    kill_region()
  return
}
!w::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
    kill_ring_save()
  return
}

^x::
{
  global
  if is_target(){
    Send %ThisHotkey%
    ; Send %A_ThisHotkey%
  } else {
    is_pre_x := 1
  }
  return 
}

^y::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
    yank()
  return
}

;$^{Space}::
;^vk20sc039::
^vk20::
{
  global
  if is_target()
    Send "{CtrlDown}{Space}{CtrlUp}"
  else
  {
    if is_pre_spc
      is_pre_spc := 0
    else
      is_pre_spc := 1
  }
  return
}
^@::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
  {
    if is_pre_spc
      is_pre_spc := 0
    else
      is_pre_spc := 1
  }
  return
}

^/::
{
  global
  if is_target()
    Send %A_ThisHotkey%
  else
    undo()
  return  
} 

h::  ;Ctrl-x,h  bind to select_all
{
  global
  if is_target(){
    ;; In AHK 2.0 alpha, single character is NOT seen as "hotkey". So we cannot use %A_ThisHotkey%
    Send "h"
  } else if (is_pre_x) {
      select_all()
  } else {
      Send "h"
  }
  return
}

k::  ;Ctrl-x, k bind to kill_buffer
{
  global
  if is_target(){
    Send "k"
  } else if (is_pre_x) {
      kill_buffer()
  } else {
      Send "k"
  }
  return
}